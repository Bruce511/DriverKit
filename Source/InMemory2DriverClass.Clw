!------------------------------------------------------------------------------------------------
!   CapeSoft Clarion File Driver Kit classes are copyright © 2025 by CapeSoft                   !
!   Docs online at : https://capesoft.com/docs/Driverkit/ClarionObjectBasedDrivers.htm
!   Released under MIT License
!------------------------------------------------------------------------------------------------

  Member()
  Map
    Module('Windows')
      osOutputDebugString(*cstring msg), raw, pascal, name('OutputDebugStringA')
      osSHGetFolderPath(long pHandle, long pCSIDL, long hToken, long pFlags, *CSTRING szPath),long, raw, pascal, name('SHGetFolderPathA'), dll(1)
    End
    Module('SQLite api')
      sqlite3_open_v2(*cString pFileName,Long pHandleAddress, Long pFlags, Long pVFS),Long,C,Raw,name('sqlite3_open_v2') ! filename in utf-8 format
      sqlite3_close(Long pHandle),Long,C,Proc
    End
  End

  include('InMemory2DriverClass.Inc'),once
  include('StringTheory.inc'),Once
  include('Errors.clw'),once

! normally one would not put global, unthreaded, variables into the class module.
! but these are read from an INI File, so we don't want to do it per-object. They are
! per-driver, so reading them when initing the first object is enough. If the INI value changes
! the program will need to be restarted to see the effect.

driver:loaded          byte
driver:trace           byte          ! trace calls to the backend
driver:BindData        byte          ! show bound data
driver:Profile         byte          ! show clarion statements
driver:Flush           byte          ! flush after write
driver:DebugLog        byte          ! Output to Debugview
driver:Details         byte          ! show record buffer contents
driver:TraceIntoFiles  byte          ! log commands generated by view engine
driver:TraceFile       aString       ! file to store tracing in

!-----------------------------------------------------------------
! Once the last connection closes, the database goes away.
! So for each database encountered, a connection needs to be made, and kept open.
! for now, we'll just put them in a queue
! This queue is global, not threaded. So is accessible to all objects on all threads.
InMemThreadManager  DriverInMemoryThread,Thread

DBQCS               DriverCriticalSection

DatabaseQueue       Queue
Owner                 cString(255)
dbHandle              Long
Thread                Long
                    End


!-----------------------------------------------------------------
DriverInMemoryThread.Trace                        Procedure(String pStr)
cstr  Cstring(size(pStr) + 10)
  code
  cstr = '[' & thread() & '][imt]' & pStr
  osOutputDebugString(cstr)

!-----------------------------------------------------------------
DriverInMemoryThread.Construct                    Procedure()
  Code

!-----------------------------------------------------------------
! So when a thread destructs then any threaded databases need to be cleaned up.
DriverInMemoryThread.Destruct                     Procedure()
result   long,auto
t        long,auto
  Code
  t = thread()
  DBQCS.wait()
  Loop
    DatabaseQueue.Thread = t
    Get(DataBaseQueue,DatabaseQueue.Thread)
    If Errorcode() then break.
    ! There's a threaded-content database, and the thread is ending, so let's close the permanent connection.
    If DatabaseQueue.dbHandle
      result = sqlite3_close(DatabaseQueue.dbHandle)
    End
    Delete(DataBaseQueue)
  End
  DBQCS.release()
  Return

!=============================================================================================================
!-----------------------------------------------------------------
DriverFileInMemory2Class.CONSTRUCT        Procedure()
  Code
  self._ThisSqlType = 'INMEM2TYPE'    ! used in dict in extended attributes to identify type settings specific to INMEM driver
  Return

!-----------------------------------------------------------------
! loads Driver-Wide values from an INI file when the first file in this driver is Initialized.
! Although this code is common to all the drivers, it can't be moved into the base class because of the
! global module variables.
DriverFileInMemory2Class.LoadLogging  procedure
CSIDL_APPDATA  Equate(01Ah)
iniName        cstring(255)
inisection     string(50),auto
str            StringTheory
root           Long,auto
  code
  !self.trace('DriverFileMSSQL2Class.LoadLogging sdt=' & System{prop:DriverTracing} & ' driver:loaded=' & driver:loaded)
  If driver:loaded
    do InitLogVars
    Return
  End
  driver:loaded = true
  If System{prop:DriverTracing} = 0 then return.

  inisection = 'CW' & self.GetProp:Driver()
  !self.trace('inisection=' & inisection & '  tk=' & system{PROP:TraceKey})
  ! Check if global trace settings are set in the registry
  If system{PROP:TraceKey}
    str.SetValue(system{PROP:TraceKey})
    str.split('\')
    case upper(str.GetLine(1))
    of 'HKEY_CLASSES_ROOT'
      root = REG_CLASSES_ROOT
    of 'HKEY_CURRENT_USER_ROOT'
      root = REG_CURRENT_USER
    of 'HKEY_LOCAL_MACHINE'
      root = REG_LOCAL_MACHINE
    of 'HKEY_USERS'
      root = REG_USERS
    of 'HKEY_CURRENT_CONFIG'
      root = REG_CURRENT_CONFIG
    else
      root = 0
    End
    Str.DeleteLine(1)
    Str.Join('/')
    driver:trace           = GetReg(root,str.GetValue(),'Trace')             ! trace calls to the backend
    driver:BindData        = GetReg(root,str.GetValue(),'BindData')          ! show bound data
    driver:Profile         = GetReg(root,str.GetValue(),'Profile')           ! show clarion statements
    driver:Flush           = GetReg(root,str.GetValue(),'Flush')             ! flush after write
    driver:DebugLog        = GetReg(root,str.GetValue(),'DebugLog')          ! Output to Debugview
    driver:Details         = GetReg(root,str.GetValue(),'Details')           ! show record buffer contents
    driver:TraceIntoFiles  = GetReg(root,str.GetValue(),'TraceIntoFiles')    ! log commands generated by view engine
    driver:TraceFile       = GetReg(root,str.GetValue(),'TraceFile')            ! file to store tracing in
  Else
  ! Check if global trace settings are set in a custom inifile
    If system{PROP:TraceFile} = 'default'
      If osSHGetFolderPath(0, CSIDL_APPDATA, 0, 0, iniName) = 0
        ininame = iniName & '\SoftVelocity\Clarion\Drivers.ini'
      End
    ElsIf system{PROP:TraceFile}
      ininame = system{PROP:TraceFile}
    End
    !self.trace('IniName=' & clip(IniName) & ' inisection=' & inisection)
    If IniName
      driver:trace           = GetIni(inisection,'Trace',0,ininame)          ! trace calls to the backend               --
      driver:BindData        = GetIni(inisection,'BindData',0,ininame)       ! show bound data
      driver:Profile         = GetIni(inisection,'Profile',0,ininame)        ! show clarion statements
      driver:Flush           = GetIni(inisection,'Flush',0,ininame)          ! flush after write
      driver:DebugLog        = GetIni(inisection,'DebugLog',0,ininame)       ! Output to Debugview
      If driver:Profile
        driver:Details         = GetIni(inisection,'Details',0,ininame)        ! show record buffer contents
      Else
        driver:Details = 0
      End
      driver:TraceIntoFiles  = GetIni(inisection,'TraceIntoFiles',0,ininame) ! log commands generated by view engine
      driver:TraceFile       = GetIni(inisection,'TraceFile',0,ininame)      ! file to store tracing in                 --
    End
  End
  do InitLogVars
  !self.trace('loadlogging done driver:trace=' & driver:trace & ' driver:BindData=' & driver:BindData & ' driver:Profile=' & driver:Profile & ' driver:Flush=' & driver:Flush & ' driver:DebugLog=' & driver:DebugLog & ' driver:Details=' & driver:Details & ' driver:TraceIntoFiles=' & driver:TraceIntoFiles & ' driver:TraceFile=' & driver:TraceFile)

InitLogVars  routine
  self._logClarion = driver:Profile
  self._logSQL     = driver:trace
                   ! = driver:Flush
  self._logBind    = driver:BindData
  self._logData    = driver:Details
  self._logOptions = driver:trace ! same as SQL
  self._logExplain = false
  self._logConnections = driver:trace ! same as SQL
  self._LogFile = driver:TraceFile

!-----------------------------------------------------------------
DriverFileInMemory2Class.PushDatabase      Procedure(string pOwner)
saveowner cstring(255),auto
options   long,auto
result    long,auto
x         Long,auto
  code
  DBQCS.wait()
  saveOwner = pOwner
  x = instring('?',pOwner,1,1)
  If x then pOwner = sub(pOwner,1,x-1).
  DatabaseQueue.Owner = clip(lower(pOwner))                        ! note this queue is not a property. It's a global, unthreaded queue.
  Get(DatabaseQueue,DatabaseQueue.Owner)
  If errorcode()
    Options =  SQLITE_OPEN_READWRITE + SQLITE_OPEN_CREATE
    If sub(DatabaseQueue.Owner,1,5) = 'file:'
      Options = Bor(Options,SQLITE_OPEN_URI)
    End
    result = sqlite3_open_v2(saveOwner,address(DatabaseQueue.dbHandle), Options ,0)
    If self.opt:ThreadedContent
      DatabaseQueue.Thread = thread()
    Else
      DatabaseQueue.Thread = 1  ! so databases with not /ThreadedContent will die when thread 1 ends.
    End
    If result = SQLite_Ok
      Add(DatabaseQueue)
    End
  End
  DBQCS.release()
  Return

!-----------------------------------------------------------------
! In derived classes derive this method with this exact same code, but
! replace the declaration of old with your class name. DO NOT call the parent class.
DriverFileInMemory2Class.ReplaceObject        Procedure(Long pOldObjectAddress)
old    &DriverFileInMemory2Class
  Code
  If pOldObjectAddress <> 0
    old &= (pOldObjectAddress)
    self :=: old
    Dispose(old)
  End
  self.ClaFCB.rblock = address(self)
  Return

!-----------------------------------------------------------------
DriverFileInMemory2Class.SetDriverOption     Procedure(String pOption, String pValue)
  Code
  Case upper(pOption)
  Of '/THREADEDCONTENT'
    self.opt:ThreadedContent = TRUE
  End
  Return Parent.SetDriverOption(pOption,pValue)

!-----------------------------------------------Procedure----------------
DriverFileInMemory2Class.CONNECT             PROCEDURE(Long pOptions=0)
  Code
  If Errorcode() = 0
    self.PushDatabase(self.Owner)
  End
  pOptions = SQLITE_OPEN_READWRITE + SQLITE_OPEN_CREATE + SQLITE_OPEN_URI
  Parent.Connect(pOptions)
  Return

!-----------------------------------------------------------------
! In the Memory Driver, Disconnect "does nothing"
! Threaded databases will be destroyed by the DESTRUCT of the DriverInMemoryThread object
! Unthreaded databases exist forever, and will be cleaned up when the program closes.
DriverFileInMemory2Class.DISCONNECT     PROCEDURE()!
!result  Long,Auto
!stmt    Long
  Code
!  parent.Disconnect()
!  If self.dbHandle
!    If ConnectionPoolSQlite2.Disconnect(self.dbHandle) = true
!      result = sqlite3_close(self.dbHandle)
!      self.SetErrorSqlite(result,'[p115]')
!    End
!    self.dbHandle = 0
!  End
  Return
!-----------------------------------------------------------------
! no need for stream optimization in mem driver
DriverFileInMemory2Class.STREAM           PROCEDURE()
  Code
  If self._logClarion then self.Log('[CLAR]STREAM()').
  self.SetError(NoError)
  Return

!-----------------------------------------------------------------
DriverFileInMemory2Class._UpdateFileStrings  Procedure()
s  cstring(255)
  Code
  If self._locknames = false
    parent._UpdateFileStrings()
    s = self.Owner
    if s = '' then s = 'memdb'.
    If self.opt:ThreadedContent then s = s & thread().
    self.Owner        = 'file::'& s &'?mode=memory&cache=shared&journal_mode=MEMORY&synchronous=OFF&busy_timeout=30000'
  End
  Return

!-----------------------------------------------------------------
DriverFileInMemory2Class.GETPROP:Driver   PROCEDURE()
  code
  Return 'InMemory2'

!-----------------------------------------------------------------
DriverFileInMemory2Class.GETPROP:DriverVersion  PROCEDURE()
  code
  Return driver:version

!-----------------------------------------------------------------
DriverViewInMemory2Class.GETPROP:Driver   PROCEDURE()
  code
  Return 'InMemory2'

!-----------------------------------------------------------------
